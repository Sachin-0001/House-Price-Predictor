# -*- coding: utf-8 -*-
"""House price predictor

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mSJn_N15ZyvhXzN7a7C1ELwtkD7FYbV9
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

dataset= pd.read_csv('Bengaluru_House_Data.csv')
X=dataset.iloc[:,:-1]
y=dataset.iloc[:,-1]

print(X)

print(y)

def convert_sqft(x):
    try:
        # Handle range values like '2100 - 2850'
        if '-' in str(x):
            tokens = x.split('-')
            return (float(tokens[0].strip()) + float(tokens[1].strip())) / 2
        # Handle pure numbers
        return float(x)
    except:
        # For values like '34.46Sq. Meter', extract the number and convert to sqft if possible
        import re
        match = re.match(r"([\d\.]+)\s*Sq. Meter", str(x))
        if match:
            return float(match.group(1)) * 10.7639  # 1 sqm = 10.7639 sqft
        match = re.match(r"([\d\.]+)\s*Sq. Yards", str(x))
        if match:
            return float(match.group(1)) * 9.0  # 1 sq yard = 9 sqft
        match = re.match(r"([\d\.]+)\s*Acres", str(x))
        if match:
            return float(match.group(1)) * 43560  # 1 acre = 43560 sqft
        match = re.match(r"([\d\.]+)\s*Perch", str(x))
        if match:
            return float(match.group(1)) * 272.25  # 1 perch = 272.25 sqft
        match = re.match(r"([\d\.]+)\s*Guntha", str(x))
        if match:
            return float(match.group(1)) * 1089  # 1 guntha = 1089 sqft
        match = re.match(r"([\d\.]+)\s*Grounds", str(x))
        if match:
            return float(match.group(1)) * 2400  # 1 ground = 2400 sqft
        # If all fails, return NaN
        return np.nan

X['total_sqft'] = X['total_sqft'].apply(convert_sqft)

from sklearn.impute import SimpleImputer
imputer = SimpleImputer(strategy='mean')
imputer.fit(X.iloc[:, 5:8])  # columns 6 and 7: 'bath', 'balcony'
X.iloc[:, 5:8] = imputer.transform(X.iloc[:, 5:8])

from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder

categorical_cols = ['area_type', 'availability', 'location', 'size', 'society']

ct = ColumnTransformer(
    transformers=[
        ('cat', OneHotEncoder(), categorical_cols)
    ],
    remainder='passthrough'
)
X = ct.fit_transform(X)

print(X)

from sklearn.model_selection import train_test_split
X_train, X_test, y_train,y_test=train_test_split(X, y,test_size=0.2,random_state=1)

print(X_train)

print(y_test.values)

from sklearn.preprocessing import StandardScaler
sc = StandardScaler(with_mean=False)
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

from sklearn.ensemble import RandomForestRegressor
regressor=RandomForestRegressor(n_estimators=18 , random_state=0)
regressor.fit(X_train,y_train)

y_pred=regressor.predict(X_test)
print(y_pred)

# Example of calculating a custom "accuracy" for regression
# Define a tolerance level (e.g., predictions within 10% of the actual value)
tolerance = 0.10
correct_predictions = np.sum(np.abs(y_test - y_pred) / y_test < tolerance)
total_predictions = len(y_test)
custom_accuracy = correct_predictions / total_predictions

print(f"Custom Accuracy (within {tolerance*100}% tolerance): {custom_accuracy}")